use crate::db::slice::Slice;
use crate::util::buffer::{BufferReader, BufferWriter};
use crate::util::hash::hash;

pub trait FilterPolicy {
    // Return the name of this policy.  Note that if the filter encoding
    // changes in an incompatible way, the name returned by this method
    // must be changed.  Otherwise, old incompatible filters may be
    // passed to methods of this type.
    fn name(&self) -> &'static str;

    // keys[0,n-1] contains a list of keys (potentially with duplicates)
    // that are ordered according to the user supplied comparator.
    // Append a filter that summarizes keys[0,n-1] to *dst.
    //
    // Warning: do not change the initial contents of *dst.  Instead,
    // append the newly constructed filter to *dst.
    fn create_filter(&self, keys: &Vec<Slice>, dst: &mut Vec<u8>);

    // "filter" contains the data appended by a preceding call to
    // create_filter() on this class.  This method must return true if
    // the key was in the list of keys passed to create_filter().
    // This method may return true or false if the key was not on the
    // list, but it should aim to return false with a high probability.
    fn key_may_match(&self, key: Slice, filter: Slice) -> bool;
}

fn bloom_hash(key: &[u8]) -> u32 {
    hash(key, 0xbc9f1d34)
}

struct BloomFilterPolicy {
    bits_per_key: usize,
    hash_num: usize,
}

impl BloomFilterPolicy {
    pub fn new(bits_per_key: usize) -> Self {
        // We intentionally round down to reduce probing cost a little bit
        let mut hash_num = (bits_per_key as f64 * 0.69) as usize;
        if hash_num < 1 {
            hash_num = 1;
        }
        if hash_num > 30 {
            hash_num = 30;
        }

        BloomFilterPolicy {
            bits_per_key,
            hash_num,
        }
    }
}

impl FilterPolicy for BloomFilterPolicy {
    fn name(&self) -> &'static str {
        "leveldb.BuiltinBloomFilter2"
    }

    fn create_filter(&self, keys: &Vec<Slice>, dst: &mut Vec<u8>) {
        // Compute bloom filter size (in both bits and bytes)
        let mut bits = keys.len() * self.bits_per_key;

        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if bits < 64 {
            bits = 64;
        }

        let bytes = (bits + 7) / 8;
        bits = bytes * 8;

        let init_size = dst.len();
        dst.resize(init_size + bytes, 0);
        dst.push(self.hash_num as u8); // Remember # of probes in filter
        let mut data = dst.as_mut_slice();
        unsafe { data.advance_mut(init_size) };
        for key in keys {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            let mut h = bloom_hash(key.as_ref()) as usize;
            let delta = (h >> 7) | (h << 15);
            for _ in 0..self.hash_num {
                let bitpos = h % bits;
                data[bitpos / 8] |= (1 << (bitpos % 8) as u8);
                h += delta;
            }
        }
    }

    fn key_may_match(&self, key: Slice, filter: Slice) -> bool {
        let len = filter.size();
        if len < 2 {
            return false;
        }

        let array = filter.as_ref();
        let bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        let hash_num = array[array.len() - 1] as usize;
        if hash_num > 30 {
            return true;
        }

        let mut h = bloom_hash(key.as_ref()) as usize;
        let delta = (h >> 7) | (h << 15);
        for _ in 0..hash_num {
            let bitpos = h % bits;
            if array[bitpos / 8] & (1 << (bitpos % 8) as u8) == 0 {
                return false;
            }
            h += delta;
        }
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use byteorder::{LittleEndian, WriteBytesExt};
    use std::rc::Rc;

    fn key(i: u32, buffer: &mut Vec<u8>) -> Slice {
        buffer.clear();
        buffer.write_u32::<LittleEndian>(i).unwrap();
        Slice::new(buffer.as_ptr(), buffer.len())
    }

    struct BloomTest {
        keys: Vec<Vec<u8>>,
        filter: Vec<u8>,
        policy: Rc<dyn FilterPolicy>,
    }

    impl BloomTest {
        pub fn new() -> Self {
            let policy = Rc::new(BloomFilterPolicy::new(10));
            BloomTest {
                keys: Vec::new(),
                filter: Vec::new(),
                policy,
            }
        }

        pub fn add(&mut self, s: Slice) {
            let mut v = Vec::new();
            v.extend_from_slice(s.as_ref());
            self.keys.push(v);
        }

        pub fn build(&mut self) {
            let mut slices = Vec::new();
            for key in self.keys.iter() {
                let s = Slice::new(key.as_ptr(), key.len());
                slices.push(s);
            }
            self.filter.clear();
            self.policy.create_filter(&slices, &mut self.filter);
            self.keys.clear();
        }

        pub fn matches(&mut self, s: Slice) -> bool {
            if !self.keys.is_empty() {
                self.build();
            }
            self.policy.key_may_match(s, self.filter.as_slice().into())
        }

        pub fn false_positive_rate(&mut self) -> f64 {
            let mut buf = Vec::with_capacity(std::mem::size_of::<u32>());
            let mut result = 0;
            for i in 0..10000 {
                if self.matches(key(i + 1000000000, &mut buf)) {
                    result += 1;
                }
            }

            result as f64 / 10000.0
        }

        pub fn reset(&mut self) {
            self.keys.clear();
            self.filter.clear();
        }

        pub fn filter_size(&self) -> usize {
            self.filter.len()
        }
    }

    #[test]
    fn test_empty_filter() {
        let mut tester = BloomTest::new();
        assert!(!tester.matches("hello".as_bytes().into()));
        assert!(!tester.matches("world".as_bytes().into()));
    }

    #[test]
    fn test_small() {
        let mut tester = BloomTest::new();
        tester.add("hello".as_bytes().into());
        tester.add("world".as_bytes().into());
        assert!(tester.matches("hello".as_bytes().into()));
        assert!(tester.matches("world".as_bytes().into()));
        assert!(!tester.matches("x".as_bytes().into()));
        assert!(!tester.matches("foo".as_bytes().into()));
    }

    fn next_length(length: u32) -> u32 {
        if length < 10 {
            length + 1
        } else if length < 100 {
            length + 10
        } else if length < 1000 {
            length + 100
        } else {
            length + 1000
        }
    }

    //TODO: the false positive rate is too high, reduce it
    #[test]
    fn test_varying_lengths() {
        let mut mediocre_filters = 0;
        let mut good_filters = 0;
        let mut buffer = Vec::new();

        let mut length = 1;
        while length <= 10000 {
            let mut tester = BloomTest::new();
            tester.reset();
            for i in 0..length {
                tester.add(key(i, &mut buffer));
            }
            tester.build();

            assert!(tester.filter_size() <= ((length * 10 / 8) + 40) as usize);

            // All added keys must match
            for i in 0..length {
                assert!(tester.matches(key(i, &mut buffer)));
            }

            // Check false positive rate
            let rate = tester.false_positive_rate();
            println!(
                "rate {}, len {}, byte {} ",
                rate,
                length,
                tester.filter_size()
            );
            assert!(rate <= 0.027);
            if rate > 0.0125 {
                mediocre_filters += 1;
            } else {
                good_filters += 1;
            }

            length = next_length(length);
        }
        assert!(mediocre_filters <= good_filters / 4);
    }
}
